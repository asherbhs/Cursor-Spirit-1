<html>
    <head>
        <meta charset="utf-8">
        <title>Mute the music if it gets annoying</title>
        <style>
            body {
                margin: 0;
            }

            #gameCanvas {
                cursor: none;

                display: block;
                margin-left: auto;
                margin-right: auto;
                border-style: solid;
                border-width: 20px;
                border-color: "rgb(0, 0, 10)";
            }


        </style>
    </head>
    <body>
        <canvas id = "gameCanvas"></canvas>
        <script>
            //Variables
            
            //canvas and context
            let canvas = document.getElementById("gameCanvas");
            let width = canvas.width = 1280;
            let height = canvas.height = 720;
            let centre = [Math.round(width/2), Math.round(height/2)];
            let ctx = canvas.getContext("2d");

            //timings
            let timestamp;
            let starttime;
            let elapsed;
            let prevtime = 0;

            //assets
            let assetCount = 16;
            let assetsLoaded = 0;

            let normalForward = new Image();
            normalForward.onload = function() {
                assetsLoaded++;
            }
            normalForward.src = "assets/normal-forward.png";
            let normalSouth = new Image();
            normalSouth.onload = function() {
                assetsLoaded++;
            }
            normalSouth.src = "assets/normal-south.png";
            let normalWest = new Image();
            normalWest.onload = function() {
                assetsLoaded++;
            }
            normalWest.src = "assets/normal-west.png";
            let normalEast = new Image();
            normalEast.onload = function() {
                assetsLoaded++;
            }
            normalEast.src = "assets/normal-east.png";
            let normalSouthwest = new Image();
            normalSouthwest.onload = function() {
                assetsLoaded++;
            }
            normalSouthwest.src = "assets/normal-southwest.png";
            let normalSoutheast = new Image();
            normalSoutheast.onload = function() {
                assetsLoaded++;
            }
            normalSoutheast.src = "assets/normal-southeast.png";
            let normalBlank = new Image();
            normalBlank.onload = function() {
                assetsLoaded++;
            }
            normalBlank.src = "assets/normal-blank.png";

            let chargedForward = new Image();
            chargedForward.onload = function() {
                assetsLoaded++;
            }
            chargedForward.src = "assets/charged-forward.png";
            let chargedSouth = new Image();
            chargedSouth.onload = function() {
                assetsLoaded++;
            }
            chargedSouth.src = "assets/charged-south.png";
            let chargedWest = new Image();
            chargedWest.onload = function() {
                assetsLoaded++;
            }
            chargedWest.src = "assets/charged-west.png";
            let chargedEast = new Image();
            chargedEast.onload = function() {
                assetsLoaded++;
            }
            chargedEast.src = "assets/charged-east.png";
            let chargedSouthwest = new Image();
            chargedSouthwest.onload = function() {
                assetsLoaded++;
            }
            chargedSouthwest.src = "assets/charged-southwest.png";
            let chargedSoutheast = new Image();
            chargedSoutheast.onload = function() {
                assetsLoaded++;
            }
            chargedSoutheast.src = "assets/charged-southeast.png";
            let chargedBlank = new Image();
            chargedBlank.onload = function() {
                assetsLoaded++;
            }
            chargedBlank.src = "assets/charged-blank.png";

            let forwardImage = normalForward;
            let southImage = normalSouth;
            let westImage = normalWest;
            let eastImage = normalEast;
            let southwestImage = normalSouthwest;
            let southeastImage = normalSoutheast;
            let blankImage = normalBlank;

            let bg0 = new Image();
            bg0.onload = function() {
                assetsLoaded++;
            }
            bg0.src = "assets/dark-sky.png"

            let bg1 = new Image();
            bg1.onload = function() {
                assetsLoaded++;
            }
            bg1.src = "assets/starfield.png"

            let star = new Image()
            star.onload = function() {
                assetsLoaded++;
            }
            star.src = "assets/star.png"

            let ast = new Image()
            star.onload = function() {
                assetsLoaded++;
            }
            ast.src = "assets/asteroid.png"

            let music = new Audio()
            music.src = "assets/music.wav"

            let musicLoaded = false;
        
            //game stuff
        
            let mousePos = [0, 0];
            let posArrMax = 4;
            let mousePosArr = []; //array of the previous positions of the mouse relative to the canvas origin
            let playerPosArr = []; //array of the previous positions of the player relative to the game world origin
            for (let i = 0; i < posArrMax; i++) {
                mousePosArr.push([0, 0]);
                playerPosArr.push([0, 0]);
            }
            let mouseDown = false;
            let charged = false;
            let chargeCountdownMax = 60; //number of loops chargeCountdown will be set to upon a click
            let chargeCountdown = 0; //number of loops remaining until charge is set back to false
            let clickCount = 0; //incremented each time the mouse is clicked down

            let playerImage = forwardImage;
            let playerSize = [80, 80];
            let trailColour;
            let playerRect = [0, 0, playerSize[0], playerSize[0]]; //rect of the player in the game world

            let pan = [0, 0]; //vector from true origin to view origin
            let panScale = 0.1;
            let panAmount = 10;
            //let panMin = [-1500, -1500]
            //let panMax = [1500 - width, 1500 - height]
            let panDirection;
            let panCentre;
            let keysPressed = [];

            for (let i = 0; i < 192; i++) {
                keysPressed.push(false);
            }
            let keysFirstPressed = Array.from(keysPressed);

            let debugVal = "";

            
            let baseLevelSpeed = levelSpeed = 60;
            let baseStarSpeed = starSpeed = 50;

            let lastStarSpawn = 0;
            let lastAsteroidSpawn = 500;
            spawnThings = true;

            bg1x = [0, width]
            bg1scale = 0.1
            
            let fadeStart = 0;

            //Event listeners

            canvas.addEventListener("mousemove", function(e) { //whenever the mouse is moved on the canvas
                mousePos = [e.offsetX, e.offsetY]
            });

            canvas.addEventListener("mousedown", function(e) { //whenever the mouse is clicked down
                mouseDown = true;
                charged = true;
                chargeCountdown = chargeCountdownMax;
                clickCount++;
            });

            canvas.addEventListener("mouseup", function(e) { //whenever the mouse is unclicked
                mouseDown = false;
                charged = false;
                chargeCountdown = 0;
            });

            document.addEventListener("keydown", function(e) {
                if (keysPressed[e.keyCode]){
                    keysFirstPressed[e.keyCode] = false;
                } else {
                    keysFirstPressed[e.keyCode] = true;
                }
                keysPressed[e.keyCode] = true;

            })

            document.addEventListener("keyup", function(e) {
                keysPressed[e.keyCode] = false;
            })
            
            music.addEventListener("canplaythrough", function(e) {
                musicLoaded = true
                console.log("canplaythrough")
            });

            //Classes
            class interactText {
                constructor(text = "Hello, World!", x = 0, y = 0, fill = true, colour = "black", font = "100px sans-serif", linewidth = 1, align = "start", baseline = "top", oncharge = function() {console.log("charged")}) {
                    this.text = text;
                    this.x = x
                    this.y = y
                    this.fill = fill
                    this.colour = colour
                    this.font = font
                    this.linewidth = linewidth
                    this.align = align
                    this.baseline = baseline
                    this.rect = []
                    this.oncharge = oncharge
                    this.click;
                }

                draw() {
                    //https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_text
                    let metrics;
                    ctx.font = this.font;
                    ctx.linewidth = this.linewidth;
                    ctx.textAlign = this.align;
                    ctx.textBaseline = this.baseline;
                    
                    // if (this.rect.length !== 0) {
                    //     ctx.fillStyle = "red"
                    //     ctx.fillRect(this.rect[0] - pan[0], this.rect[1] - pan[1], this.rect[2], this.rect[3])
                    // }
                    
                    if (this.fill) {
                        ctx.fillStyle = this.colour;
                        ctx.fillText(this.text, this.x - pan[0], this.y - pan[1]);
                    } else {
                        ctx.strokeStyle = this.colour;
                        ctx.lineWidth = this.linewidth;
                        ctx.strokeText(this.text, this.x - pan[0], this.y - pan[1]);
                    }

                    if (this.rect.length === 0) {
                        metrics = ctx.measureText(this.text)
                        this.rect = [this.x - metrics.actualBoundingBoxLeft, this.y - metrics.actualBoundingBoxAscent, metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent]
                    }
                }

                charge() {
                    if (this.click !== clickCount) {
                        this.oncharge()
                        this.click = clickCount;
                    }
                }
                
            }

            class shootingStar {
                constructor() {
                    this.rect = [pan[0] + width, (Math.floor(Math.random() * (height - 40)) + pan[1]), 40, 40];
                    this.trailPath = [];
                    for (let i = 0; i < 4; i++){ 
                        this.trailPath.push([this.rect[0] + this.rect[2]/2, this.rect[1] + this.rect[3]/2])
                    }
                    this.show = true
                    this.charged = false;
                }

                action() {
                    this.rect[0] += starSpeed;
                    this.trailPath.push([this.rect[0] + this.rect[2]/2, this.rect[1] + this.rect[3]/2])
                    this.trailPath.shift()
                    if (this.show) {
                        this.draw();
                    }
                }

                charge() {
                    if (!this.charged) {
                        levelSpeed += 2
                        starSpeed += 1
                        this.show = false;

                        this.charged = true;
                    }
                }

                draw() {
                    drawTrail(this.trailPath, "white", 40)
                    ctx.fillStyle = "white"
                    ctx.drawImage(star, this.rect[0] - pan[0] - 40, this.rect[1] - pan[1] - 40)
                    //ctx.fillRect((this.rect[0] - pan[0]), (this.rect[1] - pan[1]), this.rect[2], this.rect[3])
                    //ctx.fillRect(this.rect[0], this.rect[1], this.rect[2], this.rect[3])
                }

            }

            class asteroid {
                constructor() {
                    this.rect = [pan[0] + width, (Math.floor(Math.random() * (height - 80)) + pan[1]), 120, 120];
                    this.show = true
                    this.collided = false;
                }

                action() {
                    this.rect[0] += starSpeed;
                    if (this.show) {
                        this.draw();
                    }
                }

                collide() {
                    if (!this.collided) {
                        levelSpeed = baseLevelSpeed
                        starSpeed = baseStarSpeed
                        this.show = false;

                        this.collided = true;
                    }
                }

                draw() {
                    ctx.fillStyle = "brown"
                    //ctx.fillRect((this.rect[0] - pan[0]), (this.rect[1] - pan[1]), this.rect[2], this.rect[3])
                    ctx.drawImage(ast, this.rect[0] - pan[0], this.rect[1] - pan[1])
                }

            }

            
            //Objects
            
            let shootingStars = [];
            let asteroids = [];

            introButton = new interactText("click me to start", width/2, 2*height/3, true, "red", "50px sans-serif", 5, "center", "top", function() {bubble = mainBubble; lastStarSpawn = elapsed; lastAsteroidSpawn = elapsed + 500; if (musicLoaded) {music.play()}})

            //functions

            function pass(){
                console.log("pass")
            }

            function vMag(v){ //returns the magnitude of a vector
                let sqsum = 0;
                for (let i = 0; i < v.length; i++) {
                    sqsum += v[i]**2;
                }
                return Math.sqrt(sqsum);
            }

            function vNormalise(v){ //returns the normalised form of a vector (same direction, magnitude of 1), if input vector is a 0 vector then the same zero vector is returned
                let mag = vMag(v);
                if (mag !== 0){
                    for (let i = 0; i < v.length; i++) {
                        v[i] /= mag;
                    }
                }
                return v;
            }

            function vDiff(a, b){ //returns the vector to travel from a to b, both vectors must have the same number of elements
                let v = [];
                for (let i = 0; i < a.length; i++) {
                    v.push(b[i] - a[i]);
                }
                return v;
            }

            function vSum(a, b){ //returns the sum of vectors a and b, vectors must be the same length
                let v = [];
                for (let i = 0; i < a.length; i++) {
                    v.push(a[i] + b[i]);
                }
                return v;
            }

            function vScale(v, s){ //multiplies vector v by scalar s
                for (let i = 0; i < v.length; i++) {
                    v[i] *= s;
                }
                return v;
            }

            function vDot(a, b){ //returns the dot product of vectors a and b
                let dot = 0;
                for (let i = 0; i < a.length; i++) {
                    dot += a[i]*b[i]
                } 
                return dot;
            }

            function mean(l){ //returns the mean of a list of numbers
                let sum = 0;
                for (let i = 0; i < l.length; i++) {
                    sum += l[i];
                }
                return sum/l.length
            }

            function max(a) { //finds the maximum value of an array
                let m = 0
                for (let i = 0; i < a.length; i++) {
                    if (a[i] > m) {
                        m = a[i];
                    }
                }
                return m
            }

            function min(a) { //finds the maximum value of an array
                let m = 0
                for (let i = 0; i < a.length; i++) {
                    if (a[i] < m) {
                        m = a[i];
                    }
                }
                return m
            }

            function drawLine(points, colour = "red", thickness = 5, fill = false){
                ctx.beginPath();
                ctx.lineWidth = thickness;
                ctx.moveTo(points[0][0], points[0][1]);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i][0], points[i][1]);
                }
                if (fill) {
                    ctx.fillStyle = colour;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = colour;
                    ctx.stroke();
                }
                ctx.closePath();
            }

            function drawChar() { //draws teh character image and tail
                if (charged){ //if the player is charged, show the charged image and the charged colour trail, else show the normal image
                    trailColour = "rgb(0, 200, 255)"
                    forwardImage = chargedForward
                    southImage = chargedSouth
                    westImage = chargedWest
                    eastImage = chargedEast
                    southwestImage = chargedSouthwest
                    southeastImage = chargedSoutheast
                    blankImage = chargedBlank
                } else {
                    trailColour = "rgb(255, 200, 0)"
                    forwardImage = normalForward
                    southImage = normalSouth
                    westImage = normalWest
                    eastImage = normalEast
                    southwestImage = normalSouthwest
                    southeastImage = normalSoutheast
                    blankImage = normalBlank
                }

                drawTrail(playerPosArr, trailColour, 80)

                //set the correct image depending on the direction of movement
                let v = vDiff(playerPosArr[0], playerPosArr[playerPosArr.length - 1]) //vector for previous mouse motion
                if ((vMag(v) === 0)||(vMag(v) < 10)){ //if the previous mouse movement was small or 0, keep the forward animations
                    playerImage = forwardImage
                } else {
                    vNormalise(v)
                    let angle = Math.acos(vDot([0, -1], v)); //angle from -y to the previous movement vector
                    if (angle < Math.PI*3/8){
                        playerImage = blankImage
                    } else if (angle < Math.PI*5/8){
                        if (v[0] < 0) {
                            playerImage = westImage
                        } else {
                            playerImage = eastImage
                        }
                    } else if (angle < Math.PI*7/8){
                        if (v[0] < 0) {
                            playerImage = southwestImage
                        } else {
                            playerImage = southeastImage
                        }
                    } else {
                        playerImage = southImage
                    }
                }
                ctx.drawImage(playerImage, mousePosArr[mousePosArr.length - 1][0] - playerRect[2]/2, mousePosArr[mousePosArr.length - 1][1] - playerRect[3]/2); //draw the player sprite, shifted by 40 in the negative direction as the sprite is an 80px square
                //ctx.fillRect(playerRect[0] - pan[0], playerRect[1] - pan[1], playerRect[2], playerRect[3])
            }

            function drawTrail(points, colour = "white", thick = 80) { //points is a list of points [[x1, y1], [x2, y3]...] where the first point is the skinny end of the trail
                thickness = thick/2
                let trailArr = Array.from(points);
                let p = vScale(Array.from(pan), -1);
                for (let i = 0; i < trailArr.length; i++) {
                    trailArr[i] = vSum(trailArr[i], p);
                }

                let line1 = [trailArr[0]]; //adds the first points, line1 starts at the tail end of the tail and ends at the player, line2 is in reverse, this makes drawing the trail simpler
                let line2 = [trailArr[0]];
                let v;
                let v1;
                let v2;
                let len = trailArr.length;

                for (let i = 1; i < len - 1; i++) { //deals with all but the first and last points
                    v1 = vNormalise(vDiff(trailArr[i], trailArr[i+1])); //normal vector for the next edge
                    v2 = vNormalise(vDiff(trailArr[i-1], trailArr[i])); //normal vector for the previous edge

                    v = vScale(vNormalise(vDiff(v1, v2)), thickness*i/len); //vector to move to the control point from the point
                    
                    if (vMag(v) > 0) {
                        if (v1[0]*v2[1] - v1[1]*v2[0] > 0) { //flip the direction of the vector if necessary to ensure all points on line1 or line2 fall on the same side of the mousepoint history line
                            v = vScale(v, -1);
                        }
                        line1.push(vSum(trailArr[i], v)); //add points
                        line2.unshift(vSum(trailArr[i], vScale(v, -1)));
                    } else {
                        v = vScale([v2[1], -v2[0]], thickness*i/len);
                        line1.push(vSum(trailArr[i], v));
                        line2.unshift(vSum(trailArr[i], vScale(v, -1)));
                    }
                }
                    
                v = vDiff(trailArr[len - 2], trailArr[len - 1]) //vector for the previous mouse movement
                vNormalise(v)
                vScale(v, thickness);
                v = [v[1], -v[0]];

                line1.push(vSum(trailArr[len - 1], v)); //add the last points
                line2.unshift(vSum(trailArr[len - 1], vScale(v, -1)));
                
                ctx.beginPath() //draw the tail
                ctx.lineWidth = thickness;
                let cpoint1 = line1[Math.round((line1.length-1)*0.25)] //control points are at the quartiles
                let cpoint2 = line1[Math.round((line1.length-1)*0.75)]
                ctx.moveTo(trailArr[0][0], trailArr[0][1])
                ctx.bezierCurveTo(cpoint1[0], cpoint1[1], cpoint2[0], cpoint2[1], line1[line1.length-1][0], line1[line1.length-1][1])
                ctx.lineTo(line2[0][0], line2[0][1])
                cpoint1 = line2[Math.round((line1.length-1)*0.25)]
                cpoint2 = line2[Math.round((line1.length-1)*0.75)]
                ctx.bezierCurveTo(cpoint1[0], cpoint1[1], cpoint2[0], cpoint2[1], line2[line2.length-1][0], line2[line2.length-1][1])
                ctx.fillStyle = colour;
                ctx.fill();
            }

            function inRange(v, l, u) { //returns true if l <= v <= u
                if (l <= v && v <= u) {
                    return true;
                } else {
                    return false;
                }
            }
            
            function checkRectCollide(r1, r2) { //returns true if two rects overlap, rects in form [x, y, width, height]
                if ((inRange(r1[0], r2[0], r2[0] + r2[2]) || inRange(r2[0], r1[0], r1[0] + r1[2])) && (inRange(r1[1], r2[1], r2[1] + r2[3]) || inRange(r2[1], r1[1], r1[1] + r1[3]))) {
                    return true;
                } else {
                    return false;
                }
            }

            function drawText(text = "Hello, World!", x = 0, y = 0, fill = true, colour = "black", font = "100px sans-serif", linewidth = 1, align = "start", baseline = "top") {
                //https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_text
                ctx.font = font;
                ctx.linewidth = linewidth;
                ctx.textAlign = align;
                ctx.textBaseline = baseline;
                
                if (fill) {
                    ctx.fillStyle = colour;
                    ctx.fillText(text, x, y);
                } else {
                    ctx.strokeStyle = colour;
                    ctx.lineWidth = linewidth;
                    ctx.strokeText(text, x, y);
                }
            }

            function handleStuff() {
                // //handle keys only pressed since last loop
                // if (keysFirstPressed[32]){
                //     panCentre = Array.from(mousePos);
                //     keysFirstPressed[32] = false;
                // }
                
                // //handle keys currently being held
                // if (keysPressed[37]||keysPressed[65]){
                //     pan[0] -= panAmount;
                // }

                // if (keysPressed[38]||keysPressed[87]){
                //     pan[1] -= panAmount;
                // }

                // if (keysPressed[39]||keysPressed[68]){
                //     pan[0] += panAmount;
                // }

                // if (keysPressed[40]||keysPressed[83]){
                //     pan[1] += panAmount;
                // }

                // //handle pan due to mouse pos
                // if (keysPressed[32]) {
                //     panDirection = vDiff(panCentre, mousePos);
                //     pan = vSum(pan, vScale(Array.from(panDirection), panScale));
                // }

                // //limit pan to min and max
                // if (pan[0] < panMin[0]) {
                //     pan[0] = panMin[0]
                // } else if (pan[0] > panMax[0]) {
                //     pan[0] = panMax[0]
                // }

                // if (pan[1] < panMin[1]) {
                //     pan[1] = panMin[1]
                // } else if (pan[1] > panMax[1]) {
                //     pan[1] = panMax[1]
                // }
                

                //update the array for the previous mouse positions (including pan)
                mousePosArr.push(Array.from(mousePos));
                playerPosArr.push(vSum(mousePos, pan))
                mousePosArr.shift()
                playerPosArr.shift()

                //update the player rect
                playerRect[0] = playerPosArr[playerPosArr.length - 1][0] - playerRect[2]/2;
                playerRect[1] = playerPosArr[playerPosArr.length - 1][1] - playerRect[3]/2;
            }

            function mainBubble() {
                pan[0] += levelSpeed
                handleStuff()

                ctx.drawImage(bg0, 0, 0);

                bg1x = vSum(bg1x, vScale([-1, -1], levelSpeed*bg1scale))
                if (bg1x[0] < - width) {
                    bg1x[0] += 2*width;
                }
                if (bg1x[1] < - width) {
                    bg1x[1] += 2*width;
                }

                ctx.drawImage(bg1, bg1x[0], 0);
                ctx.drawImage(bg1, bg1x[1], 0);

                for (let i = 0; i < shootingStars.length; i++) {
                    shootingStars[i].action()

                    if (checkRectCollide(playerRect, shootingStars[i].rect) && charged) {
                        shootingStars[i].charge()
                    }

                }

                for (let i = 0; i < shootingStars.length; i++) {
                    if (shootingStars[i].rect[0] < pan[0] - width) {
                        shootingStars.splice(i, 1)
                    }
                }

                if (elapsed > lastStarSpawn + 1000) {
                    if (spawnThings) {
                        shootingStars.push(new shootingStar())
                    }
                    lastStarSpawn += 1000
                }

                for (let i = 0; i < asteroids.length; i++) {
                    asteroids[i].action()

                    if (checkRectCollide(playerRect, asteroids[i].rect)) {
                        asteroids[i].collide()
                    }

                }

                for (let i = 0; i < asteroids.length; i++) {
                    if (asteroids[i].rect[0] < pan[0] - width) {
                        asteroids.splice(i, 1)
                    }
                }

                if (elapsed > lastAsteroidSpawn + 2000) {
                    if (spawnThings) {
                        asteroids.push(new asteroid())
                    }
                    lastAsteroidSpawn += 2000
                }

                // if (keysPressed[32]) {
                //     drawLine([mousePos, panCentre], "grey", 1)
                // }

                if (levelSpeed >= 150 && spawnThings) {
                    spawnThings = false;
                    levelSpeed = 1000;
                    fadeStart = timestamp;
                }

                drawChar();

                if (spawnThings) {
                    ctx.fillStyle = "rgb(0, 200, 255)"
                    ctx.fillRect(10, height - 210 + 200*(1-(levelSpeed - 50)/100), 40, 200*((levelSpeed-50)/100))
                    
                    ctx.strokeStyle = "white"
                    ctx.lineWidth = 5
                    ctx.strokeRect(10, height - 210, 40, 200)
                }

                if (!spawnThings) {
                    if (timestamp - fadeStart >= 3000) {
                        bubble = endBubble
                    }
                }

            }

            function introBubble() {
                handleStuff()
                
                ctx.fillStyle = "rgb(255, 255, 255)";
                ctx.fillRect(0, 0, width, height);

                drawText("grab shooting stars to speed up", width/2, height/3, true, "black", "50px sans-serif", 5, "center", "top")
                drawText("asteroids will slow you down if you're hit", width/2, height/2, true, "black", "50px sans-serif", 5, "center", "top")
                introButton.draw();
                if (checkRectCollide(playerRect, introButton.rect) && charged) {
                    introButton.charge()
                }

                drawChar()
            }

            function endBubble() {
                handleStuff()
                ctx.fillStyle = "rgb(255, 255, 255)";
                ctx.fillRect(0, 0, width, height);
                drawText("Well done for meeting my arbitrary goal!", width/2, height/2, true, "black", "50px sans-serif", 5, "center", "middle")

                drawChar()
            }

            let bubble = introBubble;

            function mainloop(t) {
                timestamp = t
                if (charged){
                    chargeCountdown -= 1;
                    if (chargeCountdown === 0) {
                        charged = false;
                    }
                }
                
                if (starttime === undefined) { //if this is the first time the function is called, starttime will be undefined
                    starttime = timestamp; //so the start time is the current time
                }
                elapsed = timestamp - starttime; //the time elapsed since the first call of the mainlooop

                bubble();

                if (music.ended) {music.play()}
                
                //draw the debug text
                //debugVal = 1000/(timestamp-prevtime);
                //debugVal = width
                drawText(debugVal, 50, 50, true, "red", "30px sans-serif", 1, "start", "top")

                prevtime = timestamp
                window.requestAnimationFrame(mainloop); //request the next frame
            }
            mainloop();
        </script>
    </body>
</html>